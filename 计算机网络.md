# TCP首部格式

![img](picture/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67.png)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

# TCP三次握手

![img](picture/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67.png)

假设A为客户端，B为服务器端：

### 过程：

首先B处于LISTEN(监听)状态，等待客户的连接请求。

**1.A向B发送连接请求报文，`SYN=1`,`ACK=0`,选择一个初识的序号x。**

**2.B收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，`SYN=1`,`ACK=1`，确认号为 `x+1`，同时也选择一个初始的序号 `y`。**

**3.A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为` y+1`，序号为 `x+1`。**

B 收到 A 的确认后，连接建立。

### why三次？

参考：https://www.zhihu.com/question/24853633/answer/115173386

1.因为信道不可靠，而TCP想在不可靠信道上建立可靠的传输，那么三次通信是理论上的最小值。

2.因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

3.为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

# TCP四次挥手

![img](https://camo.githubusercontent.com/209302157a20fd1f442f30199165650023d4c0815c31c9924df1ff2116ea9f1f/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f5443502545352539422539422545362541432541312545362538432541352545362538392538422545392538372538412545362539342542452545382542462539452545362538452541352e706e67)

【TCP 释放连接全过程解释】

1. 客户端发送 `FIN` 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 `FIN`，并回复 `ACK `给客户端（同意释放从客户端到服务器的连接）；客户端收到服务端回复的 `ACK`，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
3. 服务端继续发送之前没发完的数据给客户端；服务端发送 `FIN+ACK` 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
4. 客户端收到服务端的` FIN+ACK`，并回复 `ACK `给服务端（同意释放从服务端到客户端的连接）；服务端收到客户端的 `ACK` 后，释放从服务端到客户端的连接。

**【问题1】**TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

**【答案1】**建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

**【问题2】**为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

**【答案2】**因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

**【问题3】**为什么客户端释放最后需要 TIME-WAIT 等待 2MSL （最大报文存活时间）呢？

**【答案3】**

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

# TCP流量控制

##### 概念

流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。

关键在于是`接收方`通过窗口控制`发送方`的速率。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

![img](https://camo.githubusercontent.com/324e35d7ee34eb9db9f3e5d14dc3d948849afa3e62a91c4a80db156e81c811b1/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f2545352538382541392545372539342541382545352538462541462545352538462539382545372541412539372545352538462541332545382542462539422545382541312538432545362542352538312545392538372538462545362538452541372545352538382542362545342542382542452545342542452538422e706e67)

# TCP拥塞控制

##### 概念

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

##### 方法

- 慢开始( slow-start )
- 拥塞避免( congestion avoidance )
- 快重传( fast retransmit )
- 快恢复( fast recovery )

TCP的拥塞控制图

![img](https://camo.githubusercontent.com/56f29286817e27ee1efe2254a6a22c78029342fc95a72fc3135b056f8a2231f9/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f54435025453625384225413525453525413125394525453725414125393725453525384625413363776e642545352539432541382545362538422541352545352541312539452545362538452541372545352538382542362545362539372542362545372539412538342545352538462539382545352538432539362545362538332538352545352538362542352e706e67)

![img](https://camo.githubusercontent.com/f504666f5fe6b73ffd665c24b7e6da8e43ef2aa80236b364b5b36ea2e1c67b74/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f5443502545372539412538342545362538422541352545352541312539452545362538452541372545352538382542362545362542352538312545372541382538422545352539422542452e706e67)