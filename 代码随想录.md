[TOC]



# 数组

## 1.数组理论基础

跳过

## 2.二分查找

循环不变量，即在循环中默认不变的量。用于边界判断，本题习惯了用`[a,b]`双闭区间。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
         # 当left=right时，区间[left, right]依然包含一个有效的待查找元素。
        while l <= r:
            m = (l + r) // 2
            if nums[m] < target:
                l = m + 1
            elif nums[m] > target:
                r = m - 1
            else:
                return m
        return -1
```

- 时间复杂度*O*(*logN*)
- 空间复杂度*O*(*1*) 

## 3.移除元素

双指针：把不是这个元素的值，往前copy

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 快慢双指针
        cur = 0
        for i in range(len(nums)):
            if nums[i] != val:
               nums[cur] = nums[i]
               cur += 1
        return cur
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 4.有序数组的平方

双指针，数组的两端比大小，逆序放进结果中

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [-1] * n
        left, right = 0, n - 1
        while left <= right:
            lp = nums[left] * nums[left]
            rp = nums[right] * nums[right]
            if lp < rp:
                res[n - 1] = rp
                n -= 1
                right -= 1
            else:
                res[n - 1] = lp
                n -= 1
                left += 1
        return res
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 5.长度最小的子数组

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        # 滑动窗口
        l = 0
        sum = 0
        res = float("inf")
        for r in range(len(nums)):
            sum += nums[r]
            while sum >= target:
                res = min(res, r - l + 1)
                sum -= nums[l]
                l += 1
        if res == float("inf"):return 0
        return res
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 6.螺旋矩阵II

模拟，类似剑指offer 的`顺时针打印矩阵`

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[-1] * n for _ in range(n)]
        l, r, t, b = 0, n - 1, 0, n - 1
        s = 1
        while 1:
            for i in range(l,r + 1):
                res[t][i] = s
                s += 1
            t += 1
            if t > b: break
            for i in range(t,b + 1):
                res[i][r] = s
                s += 1
            r -= 1
            if r < l: break
            for i in range(r, l - 1,-1):
                res[b][i] = s
                s += 1
            b -= 1
            if b < t: break
            for i in range(b, t - 1, -1):
                res[i][l] = s
                s += 1
            l += 1
            if l > r: break
        return res
```

- 时间复杂度*O*(*N^2*)
- 空间复杂度*O*(*1*) 

# 链表

## 1.链表理论基础

略

## 2.移除链表元素

快慢双指针

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        while head and head.val == val:
            head = head.next
        if not head : return head
        cur = head.next
        pre = head
        while cur :
            if cur.val == val:
                pre.next = cur.next
            else:
                pre = pre.next
            cur = cur.next
        return head
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 3.设计链表

哨兵节点：

- 哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。

- 我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。

```python
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next = None
class MyLinkedList:
    def __init__(self):
        self.size = 0
        self.head = ListNode(0) # sentinel node as pseudo-head
    def get(self, index:int) -> int:
        if index < 0 or index >= self.size:
            return -1
        curr = self.head
        for _ in range(index + 1):
            curr = curr.next
        return curr.val
    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)
        

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size, val)
        

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        # If index is greater than the length, 
        # the node will not be inserted.
        if index > self.size:
            return
        
        # [so weird] If index is negative, 
        # the node will be inserted at the head of the list.
        if index < 0:
            index = 0
        
        self.size += 1
        # find predecessor of the node to be added
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # node to be added
        to_add = ListNode(val)
        # insertion itself
        to_add.next = pred.next
        pred.next = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        # if the index is invalid, do nothing
        if index < 0 or index >= self.size:
            return
        
        self.size -= 1
        # find predecessor of the node to be deleted
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # delete pred.next 
        pred.next = pred.next.next

作者：LeetCode
链接：https://leetcode.cn/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

双链表

```python
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next = None
        self.prev = None
class MyLinkedList:
    def __init__(self):
        self.size = 0
        # pseudo-head 和 pseudo-tail
        self.head = ListNode(0)
        self.tail = ListNode(0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, index:int) -> int:
        if index < 0 or index >= self.size:
            return -1
        if index + 1 < self.size - index:
            curr = self.head
            for _ in range(index + 1):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self.size - index):
                curr = curr.prev
        return curr.val
    def addAtHead(self, val: int) -> None:
        pred, succ = self.head, self.head.next
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add

    def addAtTail(self, val: int) -> None:
        succ, pred = self.tail, self.tail.prev
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        succ.prev = to_add
        pred.next = to_add

    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size:
            return
        if index < 0:
            index = 0
        if index < self.size-index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next
        else:
            succ = self.tail
            for _ in range(self.size - index):
                succ = succ.prev
            pred = succ.prev
        
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next.next
        else:
            succ = self.tail
            for _ in range(self.size - index - 1):
                succ = succ.prev
            pred = succ.prev.prev
        self.size -= 1
        pred.next = succ
        succ.prev = pred
```

不是很难，但是繁杂到爆炸。

不过算是了解了一些底层结构，还是有所帮助的。

## 4.反转链表

迭代：三指针

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

递归：经典（记录res)

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def recur(cur,pre):
            if not cur: return pre
            res = recur(cur.next,cur)
            cur.next = pre
            return res
        return recur(head,None)
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*) 

## 5.两两交换链表中的节点

迭代：虚拟头结点（否则需要单独处理头结点）

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummyHead = ListNode(0)
        dummyHead.next = head
        temp = dummyHead
        while temp.next and temp.next.next:
            node1 = temp.next
            node2 = temp.next.next
            temp.next = node2
            node1.next = node2.next
            node2.next = node1
            temp = node1
        return dummyHead.next
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

递归：

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        newHead = head.next
        head.next = self.swapPairs(newHead.next)
        newHead.next = head
        return newHead
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*)

 ## 6.删除链表的倒数第N个节点

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        cur = head
        for _ in range(n):
            cur = cur.next
        # 删除第一个节点
        if not cur: return head.next
        pre = head
        while cur.next:
            pre = pre.next
            cur = cur.next
        pre.next = pre.next.next
        return head
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 7.链表相交

注意判断条件，要把null也带上

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        cur1 = headA
        cur2 = headB
        while cur1 != cur2:
            if cur1:
                cur1 = cur1.next
            else:
                cur1 = headB
            if cur2:
                cur2 = cur2.next
            else:
                cur2 = headA
        return cur1
```

- 时间复杂度*O*(*N+M*)
- 空间复杂度*O*(*1*) 

## 8.环形链表I

先补充环形链表的判断，

方法1:hash

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        s = set()
        cur = head
        while cur:
            if cur in s: 
                return True
            else:
                s.add(cur)
            cur = cur.next
        return False
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*) 

方法2：双指针（一快一慢）

为了开始进入循环，起点不一致，可以理解成有虚拟头结点，并走了一步。

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next: return False
        fast = head.next
        slow = head
        while slow != fast:
            if not fast or not fast.next:return False
            slow = slow.next
            fast = fast.next.next
        return True
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 9.环形链表II

方法1：集合

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        s = set()
        cur = head
        while cur:
            if cur in s:
                return cur
            s.add(cur)
            cur = cur.next
        return None
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*) 

方法2：双指针

还带有数学的推导；大致分为两个阶段:

1.快慢指针相遇

2.头指针和慢指针在入口处相遇

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return None
        fast = head
        slow = head
        while True:
            if not fast or not fast.next:
                return None
            slow = slow.next
            fast = fast.next.next
            if slow == fast:break
        ptr = head
        while ptr != slow:
            ptr = ptr.next
            slow = slow.next
        return ptr
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

# 哈希表

## 1.哈希表理论基础

略

## 2.有效的字母异位词

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        hash = {}
        for i in s:
            if i in hash:
                hash[i] += 1
            else:
                hash[i] = 1
        for i in t:
            if i in hash:
                hash[i] -= 1
                if hash[i] < 0:
                    return False
            else:
                return False
        for k,v in hash.items():
            if v != 0:
                return False
        return True
```

- 时间复杂度*O*(*N+M*)
- 空间复杂度*O*(*n=26*) 

## 3.两个数组的交集

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        s = set()
        res = set()
        for num in nums1:
            if num not in s:
                s.add(num)
        for num in nums2:
            if num in s:
                res.add(num)
        return list(res)
```

- 时间复杂度*O*(*N+M*)
- 空间复杂度*O*(*n=9*) 

## 4.快乐数

看官方题解，最后推导出来只有两种情况；

- 最终得到1
- 最终进入一个循环中

由此可以视为隐式的环形链表判断；

方法1：set()

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        def get_next(n):
            res = 0
            while n:
                i = n % 10
                n //= 10
                res += i*i
            return res
        s = set()
        while n != 1:
            n = get_next(n)
            if n in s:
                return False
            s.add(n)
        return True
```

方法2：双指针

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        def get_next(n):
            res = 0
            while n:
                i = n % 10
                n //= 10
                res += i*i
            return res
        slow = n
        fast = get_next(n)
        while True:
            if fast == 1 or get_next(fast) == 1:
                return True
            slow = get_next(slow)
            fast = get_next(get_next(fast))
            if slow == fast:break
        return False
```

复杂度分析看题解。

## 5.两数之和

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash = {}
        for i in range(len(nums)):
            tmp = target - nums[i]
            if tmp in hash:
                return hash[tmp],i
            hash[nums[i]] = i
        return []
```

## 6.四树相加II

```python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        hash = {}
        for n1 in nums1:
            for n2 in nums2:
                if n1 + n2 in hash:
                    hash[n1 + n2] += 1
                else:
                    hash[n1 + n2] = 1
        res = 0
        for n3 in nums3:
            for n4 in nums4:
                if 0 - n3 - n4 in hash:
                    res += hash[-n3-n4] 
        return res
```

- 时间复杂度*O*(*N^2*)
- 空间复杂度*O*(N^2) 

## 7.赎金信

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        hash = {}
        for s in magazine:
            if s in hash:
                hash[s] += 1
            else:
                hash[s] = 1
        for s in ransomNote:
            if s in hash:
                hash[s] -= 1
                if hash[s] < 0:
                    return False
            else:
                return False
        return True
```

- 时间复杂度*O*(*N+M*)
- 空间复杂度*O*(*N=26*) 

## 8.三数之和

排序+双指针；

这道题的难点是去重

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        k = 0
        res = []
        for k in range(len(nums) - 2):
            if nums[k] > 0 :
                break
            if k > 0 and nums[k] == nums[k - 1]:
                continue
            i = k + 1
            j = len(nums) - 1
            while i < j:
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] == nums[i - 1]:
                        i += 1
                elif s > 0:
                    j -= 1
                    while i < j and nums[j] == nums[j + 1]:
                        j -= 1
                else:
                    res.append([nums[k],nums[i],nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] == nums[i - 1]:
                        i += 1
                    while i < j and nums[j] == nums[j + 1]:
                        j -= 1
        return res
```

- 时间复杂度*O*(*N^2*)
- 空间复杂度*O*(*logn*) 

## 9.四数之和

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n-3):
            if i > 0 and nums[i] == nums[i - 1]: continue
            for k in range(i+1,n-2):
                if k>i+1 and nums[k] == nums[k - 1]:continue
                p = k + 1
                q = n - 1
                while p < q:
                    if nums[i] + nums[k] + nums[p] + nums[q] > target:
                        q -= 1
                    elif nums[i] + nums[k] + nums[p] + nums[q] < target:
                        p += 1
                    else:
                        res.append([nums[i],nums[k],nums[p],nums[q]])
                        while p < q and nums[p] == nums[p + 1]: p += 1
                        while p < q and nums[q] == nums[q - 1]: q -= 1
                        p += 1
                        q -= 1
        return res
```

- 时间复杂度*O*(*N^3*)
- 空间复杂度*O*(*logn*) 

# 字符串

## 1.反转字符串

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left = 0
        right = len(s) - 1
        while left <= right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 2.反转字符串II

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        t = list(s)
        for i in range(0,len(t),2*k):
            t[i : i + k] = reversed(t[i:i+k])
        return ''.join(t)
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*) 

## 3.替换空格

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        t = list(s)
        res = ''
        for i in t:
            if i == ' ':
                res += '%20'
            else:
                res += i
        return res
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*)

 ## 4.翻转字符串里的单词

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res = []
        right = len(s) - 1
        while s[right] == ' ':
            right -= 1
        left = right
        while left >= 0:
            while left >=0 and s[left] != ' ':
                left -= 1
            res.append( s[left+1:right+1])
            while left >=0 and s[left] == ' ':
                left -= 1
            right = left
        return ' '.join(res)
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*1*)

## 5.左旋转字符串

python黑魔法，但考点是C++原地操作的三次翻转。

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]
```

- 时间复杂度*O*(*N*)
- 空间复杂度*O*(*N*)：切片的复杂度

## 6.实现strStr()

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        # 暴力
        if not needle:return 0
        if haystack == needle :return 0
        for i in range(len(haystack) - len(needle)+1):
            tmp = 0
            for j in range(len(needle)):
                if haystack[i + j] != needle[j]:
                    break
                else:
                    tmp += 1
            if tmp == len(needle):
                return i
        return -1
```

- 时间复杂度*O*(*NxM*)
- 空间复杂度*O*(*1*)

经典是KMP算法。

## 7.重复的子字符串

方法1：枚举

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        for i in range(1,len(s)//2 + 1):
            if len(s) % i == 0:
                if all(s[j]== s[j-i] for j in range(i,len(s))):
                    return True
        return False
```

- 时间复杂度*O*(*N^2*)
- 空间复杂度*O*(*1*)

还有两种方法不想看了，对字符串不太感冒，尤其是涉及到kmp的内容。

# 双指针法

本节的题目都做过，这里快速复习一遍。

## 1.移除元素

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        cur = 0
        for num in nums:
            if num != val:
                nums[cur] = num
                cur += 1
        return cur
```

## 2.反转字符串

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left = 0
        right = len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

##  3.替换空格

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        t = list(s)
        res = ''
        for i in t:
            if i == ' ':
                res += '%20'
            else:
                res += i
        return res
```

## 4.翻转字符串里的单词

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res = []
        right = len(s) - 1
        while right >= 0 and s[right] == ' ':
            right -= 1
        left = right
        while left >= 0:
            while left >= 0 and s[left] != ' ':
                left -= 1
            res.append(s[left+1:right+1])
            while left >= 0 and s[left] == ' ':
                left -= 1
            right = left
        return ' '.join(res)
```

## 5.翻转链表

1.迭代

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

2.递归

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def recur(cur,pre):
            if not cur: 
                return pre
            res = recur(cur.next,cur)
            cur.next = pre
            return res
        return recur(head,None)
```

## 6.删除链表的倒数第N个节点

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        cur = head
        for _ in range(n):
            cur = cur.next
        pre = head
        # 特殊情况
        if not cur: return head.next
		# 判断条件
        while cur.next:
            pre = pre.next
            cur = cur.next
        pre.next = pre.next.next
        return head
```

## 7.链表相交

细节点在判断条件，要把null也考虑进去，这里结尾处必然相交。

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        cur1 = headA
        cur2 = headB
        while cur1 != cur2:
            if cur1:
                cur1 = cur1.next
            else:
                cur1 = headB
            if cur2:
                cur2 = cur2.next
            else:
                cur2 = headA
        return cur1
```

## 8.环形链表II

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast = head
        slow = head
        while True:
            if not fast or not fast.next:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        ptr = head
        while ptr != slow:
            slow = slow.next
            ptr = ptr.next
        return slow
```

## 9.三数之和

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        n = len(nums)
        for k in range(n-2):
            if nums[k] > 0:
                break
            if k > 0 and nums[k] == nums[k-1]:
                continue
            i = k + 1
            j = n - 1
            while i < j :
                s = nums[k] + nums[i] + nums[j]
                if s > 0:
                    j -= 1
                elif s < 0:
                    i += 1
                else:
                    res.append([nums[k],nums[i],nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] == nums[i-1]:
                        i += 1
                    while i < j and nums[j] == nums[j+1]:
                        j -= 1
        return res
```

## 10.四数之和

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n-3):
            if i > 0 and nums[i] == nums[i - 1]: continue
            for k in range(i+1,n-2):
                if k>i+1 and nums[k] == nums[k - 1]:continue
                p = k + 1
                q = n - 1
                while p < q:
                    if nums[i] + nums[k] + nums[p] + nums[q] > target:
                        q -= 1
                    elif nums[i] + nums[k] + nums[p] + nums[q] < target:
                        p += 1
                    else:
                        res.append([nums[i],nums[k],nums[p],nums[q]])
                        while p < q and nums[p] == nums[p + 1]: p += 1
                        while p < q and nums[q] == nums[q - 1]: q -= 1
                        p += 1
                        q -= 1
        return res
```

# 栈与队列

## 2.用栈实现队列

```python
class MyQueue:

    def __init__(self):
        self.A = []
        self.B = []

    def push(self, x: int) -> None:
        self.A.append(x)

    def pop(self) -> int:
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B.pop()
    
    def peek(self) -> int:
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B[-1]

    def empty(self) -> bool:
        if not self.A and not self.B:
            return True
        return False
```

## 3.用队列实现栈

```python
class MyStack:

    def __init__(self):
        self.A = collections.deque()
        self.B = collections.deque()

    def push(self, x: int) -> None:
        self.A.append(x)

    def pop(self) -> int:
        while len(self.A) != 1:
            self.B.append(self.A.popleft())
        while self.B:
            self.A.append(self.B.popleft())
        return self.A.popleft()

    def top(self) -> int:
        return self.A[-1]

    def empty(self) -> bool:
        if not self.A:
            return True
        return False
```

## 4.有效的括号

```python
class Solution:
    def isValid(self, s: str) -> bool:
        tmp = []
        for c in s:
            if c == '(' or c == '[' or c == '{':
                tmp.append(c)
            if c == '}' :
                if not tmp or tmp.pop() != '{':
                    return False
            if c == ']' :
                if not tmp or tmp.pop() != '[':
                    return False
            if c == ')' :
                if not tmp or tmp.pop() != '(':
                    return False
        if tmp:
            return False
        return True
```

## 5.删除字符串中的所有相邻重复项

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = []
        for c in s:
            if res and c == res[-1]:
                res.pop()
            else:
                res.append(c)
        return ''.join(res)
```

## 6.逆波兰表达式求值

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        tmp = []
        res = 0
        for t in tokens:
            if t == '+' :
                a = int(tmp.pop())
                b = int(tmp.pop())
                tmp.append(a + b)
            elif t == '-' :
                a = int(tmp.pop())
                b = int(tmp.pop())
                tmp.append(b - a)
            elif t == '*' :
                a = int(tmp.pop())
                b = int(tmp.pop())
                tmp.append(a * b)
            elif t == '/' :
                a = int(tmp.pop())
                b = int(tmp.pop())
                tmp.append(int(b / a))
            else:
                tmp.append(t)
        return int(tmp[0])
```

## 7.滑动窗口最大值

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        window = collections.deque()
        s = collections.deque()
        res = []
        for n in nums[:k]:
            window.append(n)
            if not s or n <= s[-1]:
                s.append(n)
            else:
                while s and s[-1] < n:
                    s.pop()
                s.append(n)
        res.append(s[0])
        for i in range(k,len(nums)):
            window.append(nums[i])
            tmp = window.popleft()
            if tmp == s[0]:
                s.popleft()
            if s and nums[i] <= s[-1]:
                s.append(nums[i])
            else:
                while s and s[-1] < nums[i]:
                    s.pop()
                s.append(nums[i])
            res.append(s[0])
        return res
```

## 8.前k个高频元素

最小堆的妙用！

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        map_ = {}
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i],0) + 1
        pri_que = []
        for key,freq in map_.items():
            heappush(pri_que,(freq,key))
            if len(pri_que) > k:
                heappop(pri_que)
        
        res = [0] * k
        for i in range(k-1,-1,-1):
            res[i] = heappop(pri_que)[1]
        return res
```

# 二叉树

## 1.二叉树理论基础

## 2.二叉树递归遍历

前序

```Python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def recur(root):
            if not root:
                return 
            res.append(root.val)
            recur(root.left)
            recur(root.right)
        recur(root)
        return res
```

中序

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def recur(root):
            if not root:
                return 
            recur(root.left)
            res.append(root.val)
            recur(root.right)
        recur(root)
        return res
```

后序

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def recur(root):
            if not root:
                return
            recur(root.left)
            recur(root.right)
            res.append(root.val)
        recur(root)
        return res
```

## 3.二叉树的迭代遍历

前序：

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = [root]
        res = []
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return res
```

中序

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = []
        res = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

后序

```python
class Solution:
    def postorderTraversal(self,root: TreeNode) -> List[int]:
        if not root:
            return []
        stack = [root]
        result = []
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return result[::-1]
```

## 4.二叉树的统一迭代法

中序...还是看不懂

```python
class Solution:
	def preorderTraversal(self,root: TreeNode) -> List[int]:
        res = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right:
                    st.append(node.right)
                if node.left:
                    st.append(node.left)
                st.append(node)
                st.append(None)
            else:
                node = st.pop()
                res.append(node.val)
        return res
```

## 5.二叉树的层序遍历

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:return []
        res = []
        deque = collections.deque()
        deque.append(root)
        while deque:
            tmp = []
            n = len(deque)
            for i in range(n):
                node = deque.popleft()
                tmp.append(node.val)
                if node.left:deque.append(node.left)
                if node.right:deque.append(node.right)
            res.append(tmp)
        return res
```

## 6.翻转二叉树

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def recur(root):
            if not root:return
            tmp = root.left
            root.left = root.right
            root.right = tmp
            recur(root.left)
            recur(root.right)
        recur(root)
        return root
```

## 7.对称二叉树

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def recur(left,right):
            if not left and not right:
                return True
            if not left or not right:
                return False
            if left.val != right.val:
                return False
            return recur(left.left,right.right) and recur(left.right,right.left)
        return recur(root.left,root.right)
```

## 8.二叉树的最大深度

递归

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1
```

迭代

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:return 0
        deque = collections.deque()
        res = 0
        deque.append(root)
        while deque:
            for _ in range(len(deque)):
                node = deque.popleft()
                if node.left:deque.append(node.left)
                if node.right:deque.append(node.right)
            res += 1
        return res
```

## 9.二叉树的最小深度

递归

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        def recur(root):
            if not root: return 0 
            if not root.left and root.right:
                return 1 + recur(root.right)
            if not root.right and root.left:
                return 1 + recur(root.left)
            return 1 + min(recur(root.left),recur(root.right))
        return recur(root)
```

迭代：

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:return 0
        deque = collections.deque()
        res = 0
        deque.append(root)
        while deque:
            res += 1
            for _ in range(len(deque)):
                node = deque.popleft()
                if node.left:deque.append(node.left)
                if node.right:deque.append(node.right)
                if not node.left and not node.right:
                    return res
        return res
```

## 10.完全二叉树的节点个数

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left = root.left
        right = root.right
        leftDepth = 0
        rightDepth = 0
        while left:
            left = left.left
            leftDepth += 1
        while right:
            right = right.right
            rightDepth += 1
        if leftDepth == rightDepth:
            return (2 << rightDepth) - 1
        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

## 11.平衡二叉树

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def recur(root):
            if not root:return 0
            left_depth = recur(root.left)
            if left_depth == -1 : return -1
            right_depth = recur(root.right)
            if right_depth == -1 : return -1
            return max(left_depth,right_depth) + 1 if abs(left_depth - right_depth) <= 1 else -1
        return recur(root) != -1
```

## 12.二叉树的所有路径

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        self.path = []
        self.res = []
        def recur(root):
            self.path.append(str(root.val))
            # 到达叶子节点
            if not root.left and not root.right:
                s = '->'.join(self.path)
                self.res.append(s)
                return
            if root.left:
                recur(root.left)
                self.path.pop()
            if root.right:
                recur(root.right)
                self.path.pop()
        recur(root)
        return self.res
```

## 13.左叶子之和

注意是左叶子，不是左节点

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        self.res = 0
        def recur(root):
            if not root:return
            if root.left:
                if not root.left.left and not root.left.right:
                    self.res += root.left.val
            recur(root.left)
            recur(root.right)
        recur(root)
        return self.res
```

## 14.找树左下角的值

方法1 递归

**如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！**

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        self.res = 0
        self.depth = -1
        def recur(root,curDepth):
            if not root.left and not root.right:
                if curDepth > self.depth:
                    self.depth = curDepth
                    self.res = root.val
            if root.left:
                curDepth += 1
                recur(root.left,curDepth)
                curDepth -= 1
            if root.right:
                curDepth += 1
                recur(root.right,curDepth)
                curDepth -= 1
            return
        recur(root,0)
        return self.res
```

方法2 迭代

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        # 层序遍历
        deque = collections.deque()
        deque.append(root)
        res = 0
        while deque:
            for i in range(len(deque)):
                node = deque.popleft()
                if i==0 : res = node.val 
                if node.left: deque.append(node.left)
                if node.right: deque.append(node.right)
        return res
```

## 15.路径总和

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        self.res = False
        def recur(root,path):
            if self.res:return
            if not root:return
            path += root.val
            if not root.left and not root.right and path == targetSum:
                self.res = True
                return
            recur(root.left,path)
            recur(root.right,path)
        recur(root,0)
        return self.res            
```

路径总和II

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        path = []
        def recur(root,cur):
            if not root: return
            path.append(root.val)
            cur -= root.val
            if cur == 0 and not root.left and not root.right:
                res.append(list(path))
            recur(root.left,cur)
            recur(root.right,cur)
            path.pop()
        recur(root,targetSum)
        return res
```

总结：全局变量需要增加回溯，但是局部变量不用。

## 16.从中序与后序遍历序列构造二叉树

参考剑指Offer的重建二叉树，不同的这里是从中序和后序来的。注意顺序。

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if inorder:
            print(inorder,postorder)
            node = TreeNode(postorder.pop())
            i = inorder.index(node.val)
            node.right = self.buildTree(inorder[i+1:],postorder)
            node.left = self.buildTree(inorder[:i],postorder)
            return node
```

剑指原题，从前序和中序构造二叉树

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if inorder:
            node = TreeNode(preorder.pop(0))
            i = inorder.index(node.val)
            node.left = self.buildTree(preorder,inorder[:i])
            node.right = self.buildTree(preorder,inorder[i+1:])
            return node
```

仅知道前序和后序，无法构造。

## 17.最大二叉树

与上题基本类似。

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if nums:
            node = TreeNode(max(nums))
            i = nums.index(node.val)
            node.left = self.constructMaximumBinaryTree(nums[:i])
            node.right = self.constructMaximumBinaryTree(nums[i+1:])
            return node
```

## 18.合并二叉树

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return 
        if not root1:
            return root2
        if not root2:
            return root1
        node = TreeNode(root1.val + root2.val)
        node.left = self.mergeTrees(root1.left,root2.left)
        node.right = self.mergeTrees(root1.right,root2.right)
        return node
```

## 19.二叉搜索树中的搜索

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        def recur(root):
            if not root:return
            if root.val > val:
                res = recur(root.left)
            elif root.val < val:
                res = recur(root.right)
            else:
                return root
            return res
        return recur(root)
```

## 20.验证二叉搜索树

谨记二叉搜索树的中序遍历是有序递增数组！

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.maxValue = -float("+inf")
        def recur(root):
            if not root: return True
            left = recur(root.left)
            if self.maxValue >= root.val:
                return False
            else:
                self.maxValue = root.val
            right = recur(root.right)
            return left and right
        return recur(root)
```

## 21.二叉搜索树的最小绝对值差

记录上一个值 self.pre的写法可以留意一下。

```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.res = float("+inf")
        self.pre = None
        def recur(root):
            if not root: return
            recur(root.left)
            if self.pre:
                self.res = min(self.res,root.val - self.pre.val)
            self.pre = root
            recur(root.right)
        recur(root)
        return self.res
```

## 22.二叉搜索树中的众数

对count和maxcount的处理还是很有趣的。

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.res = []
        self.pre = None
        self.count = 0
        self.maxCount = 1
        def recur(root):
            if not root:return
            recur(root.left)
            if not self.pre:
                self.count = 1
            elif self.pre.val == root.val:
                self.count += 1
            else:
                self.count = 1
            self.pre = root
            if self.count == self.maxCount:
                self.res.append(root.val)
            if self.count > self.maxCount:
                self.maxCount = self.count
                self.res = [root.val]
            recur(root.right)
        recur(root)
        return self.res
```

## 23.二叉树的最近公共祖先

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if not left and not root: return None
        if not left : return right
        if not right: return left
        return root
```

## 24.二叉搜索树的最近公共祖先

方法1 迭代

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val > q.val:
            p, q = q, p        
        while root:
            if root.val > q.val:
                root = root.left
            elif root.val < p.val:
                root = root.right
            else:
                break
        return root
```

方法2 递归

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)
        return root
```

## 25.二叉搜索树中的插入操作

```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return TreeNode(val)
        node = root
        while node:
            if val > node.val:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(val)
                    break
            else:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(val)
                    break
        return root
```

## 26.删除二叉搜索树中的节点

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root : return
        if root.val < key:
            root.right = self.deleteNode(root.right,key)
        elif root.val > key:
            root.left = self.deleteNode(root.left,key)
        else :
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            node = root.right
            while node.left:
                node = node.left
            node.left = root.left
            root = root.right
        return root
```

## 27.修剪二叉搜索树

```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root: return None
        if root.val < low:
            return self.trimBST(root.right, low, high)
        if high < root.val:
            return self.trimBST(root.left,low, high)
        if low <= root.val <= high:
            root.left = self.trimBST(root.left, low, high)
            root.right = self.trimBST(root.right, low, high)
            return root
```

## 28.将有序数组转换为二叉搜索树

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums: return None
        middle = len(nums) // 2
        root = TreeNode(nums[middle])
        root.left = self.sortedArrayToBST(nums[:middle])
        root.right = self.sortedArrayToBST(nums[middle+1:])
        return root
```

## 29.把二叉搜索树转换为累加树

```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.pre = 0
        def recur(root):
            if not root: return
            recur(root.right)
            root.val += self.pre
            self.pre = root.val
            recur(root.left)
        recur(root)
        return root
```

# 回溯算法

## 1.组合问题

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(n,k,startIndex):
            if len(path) == k:
                res.append(path[:])
                return
            for i in range(startIndex,n + 1):
                path.append(i)
                backtrack(n,k,i+1)
                path.pop()
        backtrack(n,k,1)
        return res
```

## 2.组合总和III

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        path = []
        self.sum = 0
        def recur(start):
            if self.sum > n:
                return 
            if self.sum == n and k == len(path):
                res.append(path[:])
                return 
            for i in range(start,10 - (k - len(path))+1):
                path.append(i)
                self.sum += i
                recur(i+1)
                path.pop()
                self.sum -= i
        recur(1)
        return res
```

## 3.电话号码的字母组合

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        phone = ["","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"]
        res = []
        self.path = ""
        def recur(cur):
            if len(digits) == len(self.path):
                res.append(self.path)
                return
            for i in range(len(phone[int(digits[cur])])):
                self.path += phone[int(digits[cur])][i]
                recur(cur + 1)
                self.path = self.path[:-1]
        recur(0)
        return res
```

**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

## 4.组合总和

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        self.sum = 0
        def recur(start):
            if self.sum > target:
                return
            if self.sum == target:
                res.append(path[:])
                return
            for i in range(start,len(candidates)):
                path.append(candidates[i])
                self.sum += candidates[i]
                recur(i)
                path.pop()
                self.sum -= candidates[i]
        recur(0)
        return res
```

## 5.组合总和II

去重，同一树层去重，同一树枝可重复。

![img](https://img-blog.csdnimg.cn/20201123202817973.png)

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []
        path = []
        used = [0] * len(candidates)
        self.sum = 0
        def recur(start):
            if self.sum > target:
                return
            if self.sum == target:
                res.append(path[:])
                return
            for i in range(start,len(candidates)):
                if i != 0 and candidates[i] == candidates[i - 1] and used[i-1] == 0:continue
                self.sum += candidates[i]
                path.append(candidates[i])
                used[i] = 1
                recur(i + 1)
                used[i] = 0
                self.sum -= candidates[i]
                path.pop()
        recur(0)
        return res
```

## 6.分割回文串

![img](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []
        def recur(start):
            if start >= len(s):
                res.append(path[:])
                return
            for i in range(start,len(s)):
                tmp = s[start:i+1]
                if tmp == tmp[::-1]:
                    path.append(tmp)
                    recur(i + 1)
                    path.pop()
                else:
                    continue
        recur(0)
        return res
```

## 7.复原IP地址

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        self.pointNum = 0
        def recur(s,start):
            if self.pointNum == 3:
                if is_valid(s,start, len(s) - 1):
                    res.append(s[:])
                return 
            for i in range(start, len(s)):
                if is_valid(s, start, i):
                    s = s[: i+1] + '.' + s[i+1:]
                    self.pointNum += 1
                    recur(s, i+2)
                    self.pointNum -= 1
                    s = s[:i+1] + s[i+2:]
                else:
                    break
        def is_valid(s,start,end):
            if start > end: return False
            if s[start] == '0' and start != end:
                return False
            if not 0 <= int(s[start:end+1]) <= 255:
                return False
            return True
        if len(s) > 12:return []
        recur(s,0)
        return res
```

## 8.子集

记录节点中的每一个值

![img](https://img-blog.csdnimg.cn/202011232041348.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def recur(start):
            if start > len(nums):
                return
            res.append(path[:])
            for i in range(start,len(nums)):
                path.append(nums[i])
                recur(i+1)
                path.pop()
        recur(0)
        return res
```

## 9.子集II

同一层去重！ 可以不用used辅助数组

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        path = []
        def recur(start):
            if start > len(nums):
                return
            res.append(path[:])
            for i in range(start,len(nums)):
                if i > start and nums[i] == nums[i-1] :
                    continue 
                path.append(nums[i])
                recur(i + 1)
                path.pop()
        recur(0)
        return res
```

## 10.递增子序列

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def recur(start):
            if start > len(nums):
                return
            if len(path) > 1:
                res.append(path[:])
            usage_list = set()
            for i in range(start,len(nums)):
                if (path and nums[i] < path[-1]) or nums[i] in usage_list:
                    continue
                usage_list.add(nums[i])
                path.append(nums[i])
                recur(i+1)
                path.pop()
        recur(0)
        return res
```

## 11.全排列

借助used数组

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        used = [0] * len(nums)
        def recur():
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i] == 1:
                    continue
                used[i] = 1
                path.append(nums[i])
                recur()
                path.pop()
                used[i] = 0
        recur()
        return res
```

## 12.全排列II

其实只多了一行，用于树层去重！

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        path = []
        used = [0] * len(nums)
        def recur():
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i] == 1 or (i > 0 and nums[i] == nums[i-1] and used[i - 1] == 0):
                    continue
                used[i] = 1
                path.append(nums[i])
                recur()
                path.pop()
                used[i] = 0
        recur()
        return res
```

## 13.重新安排行程

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        # defaultdict(list)
        tickets_dict = defaultdict(list)
        for item in tickets:
            tickets_dict[item[0]].append(item[1])
        
        path = ["JFK"]
        def recur(start):
            if len(path) == len(tickets) + 1:
                return True
            tickets_dict[start].sort()
            for _ in tickets_dict[start]:
                end = tickets_dict[start].pop(0)
                path.append(end)
                if recur(end):
                    return True
                path.pop()
                tickets_dict[start].append(end)
        recur("JFK")
        return path
```

## 14.N皇后

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        if not n: return []
        board = [['.'] * n for _ in range(n)]
        res = []
        def is_valid(board, row, col):
            for i in range(row):
                # 同列判断
                if board[i][col] == 'Q':
                    return False
            i = row - 1
            j = col - 1
            while i >= 0 and j >= 0:
                if board[i][j]== 'Q':
                    return False
                i -= 1
                j -= 1
            i = row - 1
            j = col + 1
            while i>=0 and j< n:
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
        def recur(n, row, board):
            #print("run")
            if row == n:
                temp = []
                for i in board:
                    s = ''.join(i)
                    temp.append(s)
                res.append(temp)
            
            for i in range(n):
                if is_valid(board, row, i):
                    board[row][i] = 'Q'
                    recur(n, row+1 , board)
                    board[row][i] = '.'
        recur(n, 0 , board)
        return res
```

## 15.解数独

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def is_valid(row, col, val):
            for i in range(9):
                if board[row][i] == str(val):
                    return False
            for i in range(9):
                if board[i][col] == str(val):
                    return False
            start_row = (row // 3) * 3
            start_col = (col // 3) * 3
            for i in range(start_row, start_row + 3):
                for j in range(start_col, start_col + 3):
                    if board[i][j] == str(val):
                        return False
            return True
        
        def recur():
            for i in range(len(board)):
                for j in range(len(board[0])):
                    if board[i][j] != '.': continue
                    for k in range(1,10):
                        if is_valid(i, j, k):
                            board[i][j] = str(k)
                            if recur(): return True
                            board[i][j] = '.'
                    return False
            return True
        recur()
```

# 贪心算法

## 1.分发饼干

贪心在先满足单个小孩，得到的就是全局最优，满足最多的小孩。

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i, j = 0, 0
        res = 0
        while i < len(g) and j < len(s):
            if g[i] <= s[j]:
                res += 1
                i += 1
                j += 1
            else:
                j += 1
        return res
```

## 2.摆动序列

思路不要陷到删除元素中去，而是统计峰值的个数。

![img](https://img-blog.csdnimg.cn/20201124174327597.png)

贪心：**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        pred, curd, res = 0, 0, 1
        for i in range(len(nums) - 1):
            curd = nums[i + 1] - nums[i]
            if pred * curd <= 0 and curd != 0:
                res += 1
                pred = curd
        return res
```

## 3.最大子序和

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        sum, res = 0, -float("inf")
        for num in nums:
            sum += num
            res = max(res, sum)
            if sum < 0 : sum = 0
        return res
```

## 4.买卖股票的最佳时机II

贪心：**局部最优：收集每天的正利润，全局最优：求得最大利润**。

![img](https://img-blog.csdnimg.cn/2020112917480858.png)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(1,len(prices)):
            if prices[i] - prices[i-1] > 0:
                res += prices[i] - prices[i-1]
        return res
```

## 5.跳跃游戏

贪心：**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1: return True
        r = nums[0]
        if r <= 0 : return False
        for i in range(1,len(nums)):
            r = max(r - 1, nums[i])
            if r == 0 and i != len(nums) - 1:
                return False
        return True
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1 :return True
        i = 0
        while i <= cover:
            cover = max(i + nums[i], cover)
            if cover >= len(nums) - 1:
                return True
            i += 1
        return False
```

## 6.跳跃游戏II

只能说挺难的，还是多看两遍代码才理解。

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        curCover = 0
        nextCover = 0
        res = 0
        for i in range(len(nums)):
            nextCover = max(i + nums[i], nextCover)
            if i == curCover: #到达这一步的最后
                if curCover != len(nums) -1: # 这一步不是终点
                    res += 1
                    curCover = nextCover
                    if nextCover >= len(nums) - 1:break
                else:
                    break
        return res
```

## 7.K次取反后最大化的数组和

```python
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A = sorted(A, key=abs, reverse=True) # 将A按绝对值从大到小排列
        for i in range(len(A)):
            if K > 0 and A[i] < 0:
                A[i] *= -1
                K -= 1
        if K > 0:
            A[-1] *= (-1)**K #取A最后一个数只需要写-1
        return sum(A)
```

## 8.加油站

这道贪心有点复杂呀

看了好几个题解才理解。

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0
        totalSum = 0
        start = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0 : return -1
        return start
```

## 9.分发糖果

从左往右先来一次

再从右往左，取最大值

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        candyList = [1] * len(ratings)
        for i in range(1,len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candyList[i] = candyList[i - 1] + 1
        
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candyList[i] = max(candyList[i + 1] + 1, candyList[i])
        
        return sum(candyList)
```

## 10.柠檬水找零

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        # 模拟
        lq5 = 0
        lq10 = 0
        for i in bills:
            if i == 5:
                lq5 += 1
            if i == 10:
                lq5 -= 1
                lq10 += 1
            if i == 20:
                if lq10 > 0:
                    lq10 -= 1
                    lq5 -= 1
                else:
                    lq5 -= 3
            # print(lq)
            if lq5 < 0:
                return False
        return True
```

## 11.根据身高重建队列

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1],p)
        return res
```

## 12.用最少数量的箭引爆气球

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key = lambda x:x[0])
        res = 1
        for i in range(1,len(points)):
            if points[i][0] > points[i - 1][1]:
                res += 1
            else:
                points[i][1] = min(points[i][1], points[i-1][1])
        return res
```

## 13.无重叠区间

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        res = 1
        intervals.sort(key = lambda x :x[1])
        end = intervals[0][1]
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                res += 1
                end = intervals[i][1]
        return len(intervals) - res
```

## 14.划分字母区间

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        hash = [0] * 26
        for i in range(len(s)):
            hash[ord(s[i]) - ord('a')] = i
        res = []
        left = 0
        right = 0
        for i in range(len(s)):
            right = max(right, hash[ord(s[i]) - ord('a')])
            if i == right:
                res.append(right - left + 1)
                left = right + 1
        return res
```

## 15.合并区间

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda x:x[0])
        res = []
        left = intervals[0][0]
        right = intervals[0][1]
        for i in range(1, len(intervals)):
            if intervals[i][0] <= right:
                right = max(intervals[i][1], right)
            else:
                res.append([left,right])
                left = intervals[i][0]
                right = intervals[i][1]
        res.append([left,right])
        return res
```

## 16.单调递增的数字

```python
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        a = list(str(n))
        for i in range(len(a)-1,0,-1):
            if int(a[i]) < int(a[i-1]):
                a[i-1] = str(int(a[i-1]) - 1)
                a[i:] = '9' * (len(a) - i)
        return int("".join(a))
```

## 17.买卖股票的最佳时机含手续费

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        res = 0
        minPrice = prices[0]
        for i in range(1, len(prices)):
            if prices[i] < minPrice:
                minPrice= prices[i]
            elif prices[i] >= minPrice and prices[i] <= minPrice + fee:
                continue
            else:
                res += prices[i] - minPrice -fee
                minPrice = prices[i] - fee
        return res
```

## 18.监控二叉树

```python
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        # Greedy Algo:
        # 从下往上安装摄像头：跳过leaves这样安装数量最少，局部最优 -> 全局最优
        # 先给leaves的父节点安装，然后每隔两层节点安装一个摄像头，直到Head
        # 0: 该节点未覆盖
        # 1: 该节点有摄像头
        # 2: 该节点有覆盖
        res = 0
        def recur(curr):
            nonlocal res

            if not curr:return 2
            left = recur(curr.left)
            right = recur(curr.right)

            if left == 2 and right == 2:
                return 0
            elif left == 0 or right == 0:
                res += 1
                return 1
            elif left == 1 or right == 1:
                return 2
        if recur(root) == 0:
            res += 1
        return res
```

# 动态规划

## 1.斐波那契数

```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0 or n == 1: return n
        a = 0
        b = 1
        for i in range(n - 1):
            b, a = b + a, b
        return b
```

## 2.爬楼梯

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1 or n== 2: return n
        a = 1
        b = 2
        for i in range(n - 2):
            b, a = b + a, b
        return b
```

## 3.使用最小花费爬楼梯

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        prev = 0
        curv = 0
        for i in range(2,len(cost) + 1):
            nxt = min( curv + cost[i - 1] , prev + cost[i - 2])
            prev, curv = curv, nxt
        return curv
```

## 4.不同路径

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for i in range(m)]
        for i in range(1,m):
            for j in range(n):
                if j==0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
```

## 5.不同路径II

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                # print(dp)
                if i == 0 :
                    if j == 0:
                        if obstacleGrid[0][0] == 0 :
                            dp[0][0] = 1
                        else:
                            dp[0][0] = 0
                    elif obstacleGrid[i][j] == 0 :
                        dp[i][j] = dp[i][j - 1]
                    else:
                        break
                elif j == 0:
                    if obstacleGrid[i][j] == 0:
                        dp[i][j] = dp[i-1][j]
                    else:
                        continue
                else:
                    if obstacleGrid[i][j] == 0:
                        dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]
```

## 6.整数拆分

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            # 假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：
            # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)
            # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]
            for j in range(1, i - 1):
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
        return dp[n]
```

## 7.不同的二叉搜索树

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, n + 1):
            # i是当前的总节点数
            for j in range(1, i + 1):
                # j 为当前以哪个节点为头节点
                # 左侧的节点是j-1,右侧的节点是i-j
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[-1]
```

## 8.0-1背包理论基础（一）

```python
def test_2_wei_bag_problem1(bag_size,weight, value) -> int:
    rows, cols = len(weight), bag_size + 1
    dp = [[0 for _ in range(cols)] for _ in range(rows)]
    #初始化dp数组
    for i in range(rows):
        dp[i][0] = 0
    first_item_weight, first_item_value = weight[0], value[0]
    for j in range(1, cols):
        if first_item_weight <= j:
            dp[0][j] = first_item_value
            
    # 更新dp数组：先遍历物品，再遍历背包
    for i in range(1, len(weight)):
        cur_weight, cur_val = weight[i], value[i]
        for j in range(1,cols):
            if cur_weight > j: #说明背包装不下当前物品
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - cur_weight] + cur_val)
    print(dp)

if __name__ == "__main__":
    bag_size = 4
    weight = [1,3,5]
    value = [15,20,30]
    test_2_wei_bag_problem1(bag_size, weight, value)
```

## 9.0-1背包理论基础（二）

```python
def test_1_wei_bag_problem():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4
    dp = [0] * (bag_weight + 1)
    for i in range(len(weight)):
        for j in range(bag_weight, weight[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    print(dp)
    
test_1_wei_bag_probl
```

## 10.分割等和子集

```Python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        target = sum(nums)
        if target%2 == 1: return False
        target //= 2
        dp = [0] * 10001
        for i in range(len(nums)):
            for j in range(target,nums[i] - 1, -1):
                dp[j] = max(dp[j],dp[j - nums[i]] + nums[i])
        return target == dp[target]
```

## 11.最后一块石头的重量II

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        target = sum(stones) // 2
        dp = [0] * (target+1)
        for i in range(len(stones)):
            for j in range(target, stones[i] - 1, -1):
                dp[j] = max(dp[j],dp[j - stones[i]] + stones[i])
        return sum(stones) - 2*dp[target]
```

## 12.目标和

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        s = sum(nums)
        if abs(target) > s or (s + target)%2 == 1:
            return 0
        bagSize = (s+target) // 2
        dp = [0] * (bagSize + 1)
        dp[0] = 1
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]
        return dp[-1]
```

## 13.一和零

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(m+1)]
        for str in strs:
            ones = str.count('1')
            zeros = str.count('0')
            for i in range(m, zeros - 1,-1):
                for j in range(n, ones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)
        return dp[m][n]
```

## 14.完全背包理论基础

因为可以重复，所以可以将遍历顺序变为从小到大

```python
def test():
	dp = [0]*(bag_weight + 1)
    for i in range(len(weight)):
        for j in range(weight[i], bag_weight +1):
            dp[j] = max(dp[j], dp[j-weight[i]]  + value[i])
```

## 15.零钱兑换II

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount+1)
        dp[0] = 1
        for i in range(len(coins)):
            for j in range(coins[i],amount+1):
                dp[j] += dp[j-coins[i]]
        return dp[-1]
```

## 16.组合总和IV

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)
        dp[0] = 1
        for i in range(1,target + 1):
            for j in nums:
                if i >= j:
                    dp[i] += dp[i-j]
        return dp[-1]
```

## 17.爬楼梯（进阶版）

```python
class Solution:
    def climbStairs(self, n:int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        m = 2
        for j in range(n+1):
            for step in range(1,m+1):
                if j>= step:
                    dp[j] += dp[j - step]
        return dp[n]
```

## 18.零钱兑换

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount + 1] *(amount+1)
        dp[0]=0
        for coin in coins:
            for j in range(coin, amount + 1):
                dp[j] = min(dp[j] , dp[j - coin] + 1)
        return dp[amount] if dp[amount] < amount + 1 else -1
```

## 19.完全平方数

```python
class Solution:
    def numSquares(self, n: int) -> int:
        nums = [i**2 for i in range(1, n + 1) if i**2 <= n]
        dp = [10**4]*(n + 1)
        dp[0] = 0
        for num in nums:
            for j in range(num, n + 1):
                dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]
```

## 20.单词拆分

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False] * (len(s) + 1)
        dp[0] = True
        for j in range(1, len(s) +1 ):
            for word in wordDict:
                if j >= len(word):
                    dp[j] = dp[j] or (dp[j - len(word)] and word == s[j - len(word):j])
        return dp[len(s)]
```

## 21.打家劫舍

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:return nums[0]
        dp = [0] * (len(nums))
        dp[0] = nums[0]
        dp[1] = max(nums[0],nums[1])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        return dp[-1]
```

## 22.打家劫舍II

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:return nums[0]
        res1 = self.robrange(nums[1:])
        res2 = self.robrange(nums[:-1])
        return max(res1,res2)
    def robrange(self, nums):
        if len(nums) == 1:return nums[0]
        dp = [0] * (len(nums))
        dp[0] = nums[0]
        dp[1] = max(nums[0],nums[1])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        return dp[-1]
```

## 23.打家劫舍III

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        # dp数组以及下标的含义
        # 1.下标为0记录 不偷该节点 所得到的最大金钱
        # 2.下标为1记录 偷该节点 所得到的的最大金钱
        dp = self.traversal(root)
        return max(dp)
    
    def traversal(self, node):
        if not node:
            return (0,0)
        left = self.traversal(node.left)
        right = self.traversal(node.right)

        val_0 = max(left[0], left[1]) + max(right[0], right[1])

        val_1 = node.val + left[0] + right[0]

        return (val_0,val_1)
```

## 24.买卖股票的最佳时机

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0
        dp = [[0] * 2 for _ in range(length)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1,length):
            dp[i][0] = max(dp[i-1][0],-prices[i])
            dp[i][1] = max(dp[i-1][1],prices[i] + dp[i-1][0])
        return dp[-1][1]
```

## 25.买卖股票的最佳时机II

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0]*2 for _ in range(length)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1,length):
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])
        return dp[length-1][1]
```

## 26.买卖股票的最佳时机III

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0]*5 for _ in range(length)]
        dp[0][1] = -prices[0]
        dp[0][3] = -prices[0]
        for i in range(1,length):
            dp[i][0] = dp[i-1][0]
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
        return dp[length-1][4]
```

## 27.买卖股票的最佳时机IV

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0] * (2*k+1) for _ in range(length)]
        for j in range(1, 2*k, 2):
            dp[0][j] = -prices[0]
        for i in range(1,length):
            for j in range(0, 2*k-1, 2):
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        return dp[length-1][2*k]
```

